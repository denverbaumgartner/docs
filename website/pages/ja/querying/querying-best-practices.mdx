---
title: クエリのベストプラクティス
---

The Graph provides a decentralized way to query data from blockchains via GraphQL APIs, making it easier to query data with the GraphQL language.

Learn the essential GraphQL language rules and GraphQL querying best practices.

---

## GraphQL APIのクエリ

### GraphQLクエリの構造

REST APIとは異なり、GraphQL APIは実行可能なクエリを定義するSchemaをベースに構築されています。

例えば、`token`クエリを使ってトークンを取得するクエリは次のようになります。

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

以下のような予測可能なJSONレスポンスが返ってきます（_適切な`$id`変数値を渡す場合_）。

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQLクエリは、[仕様](https://spec.graphql.org/)で定義されているGraphQL言語を使用します。

上記の `GetToken` クエリは、複数の言語部分で構成されています (以下では `[...]` プレースホルダーに置き換えられています)。

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

構文の「やるべきこと」「やってはいけないこと」を挙げればきりがありませんが、ここではGraphQLクエリを書く際に覚えておきたい基本的なルールを紹介します：

- 各`queryName`は、1回の操作で1回だけ使用しなければなりません。
- 各`フィールド`は、選択の中で一度だけ使用しなければなりません(`トークン`の下に`id`を二度照会することはできません)。
- Some `field`s or queries (like `tokens`) return complex types that require a selection of sub-field. Not providing a selection when expected (or providing one when not expected - for example, on `id`) will raise an error. To know a field type, please refer to [Graph Explorer](/network/explorer).
- 引数に代入される変数は、その型と一致しなければなりません。
- 与えられた変数のリストにおいて、各変数は一意でなければなりません。
- 定義された変数はすべて使用する必要があります。

上記のルールに従わない場合、Graph APIからエラーが発生します。

For a complete list of rules with code examples, please look at our [GraphQL Validations guide](/release-notes/graphql-validations-migration-guide/).

### GraphQL APIへのクエリの送信

GraphQLは、HTTPを介して転送される言語と一連の規約です。

これは、標準の`fetch`（ネイティブであれば、`@whatwg-node/fetch`や`isomorphic-fetch`を介しても）を使用して、GraphQL APIにクエリを送信できることを意味します。

However, as stated in ["Querying from an Application"](/querying/querying-from-an-application), it's recommend to use `graph-client` which supports unique features such as:

- クロスチェーンのサブグラフ処理：1回のクエリで複数のサブグラフからクエリを実行可能
- [自動ブロック追跡](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [自動ページング](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- 完全なタイプ付け結果

`graph-client` を使用してグラフをクエリする方法は次のとおりです。

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

その他の GraphQL クライアントの代替手段については、[「アプリケーションからのクエリ」](/querying/querying-from-an-application) で説明します。

---

## ベストプラクティス

### 常に静的なクエリを記述

一般的な (悪い) プラクティスは、次のようにクエリ文字列を動的に構築することです。

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

上記のスニペットは有効な GraphQL クエリを生成しますが、**多くの欠点**があります。

- クエリ全体を**理解するのが難しくなります**。
- 開発者は、**文字列補間を安全にサニタイズする責任がある**ということです。
- リクエストパラメータの一部として変数の値を送信しないでください。**サーバー側でのキャッシュの可能性を防止**
- それは ** ツールがクエリを静的に分析するのを防ぐ** (例: Linter、またはタイプ生成ツール) です。

このため、クエリは常に静的文字列として記述することをお勧めします:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

そうすることで**多くのメリット**がもたらされます:

- **読みやすく、メンテナンスしやすい**クエリ
- GraphQLの**サーバーは、変数のサニタイズを処理します**
- サーバーレベルで**変数がキャッシュできます**。
- **ツールでクエリを静的に分析できる**（これについては、次のセクションで詳しく説明します。）

### How to include fields conditionally in static queries

You might want to include the `owner` field only on a particular condition.

For this, you can leverage the `@include(if:...)` directive as follows:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

> 注: 反対のディレクティブは `@skip(if: ...)` です。

### Ask for what you want

GraphQL は、「欲しいものを聞いてください」というキャッチフレーズで有名になりました。

このため、GraphQLでは、個々にリストすることなくすべての利用可能なフィールドを取得する方法はありません。

- GraphQL APIをクエリする際には、実際に使用するフィールドのみをクエリするように常に考えてください。
- Make sure queries only fetch as many entities as you actually need. By default, queries will fetch 100 entities in a collection, which is usually much more than what will actually be used, e.g., for display to the user. This applies not just to top-level collections in a query, but even more so to nested collections of entities.

たとえば、次のクエリでは:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

応答には、100 個のトークンごとに 100 個のトランザクションが含まれる可能性があります。

アプリケーションが 10 トランザクションのみを必要とする場合、クエリではトランザクション フィールドに `first: 10` を明示的に設定する必要があります。

### Use a single query to request multiple records

By default, subgraphs have a singular entity for one record. For multiple records, use the plural entities and filter: `where: {id_in:[X,Y,Z]}` or `where: {volume_gt:100000}`

Example of inefficient querying:

```graphql
query SingleRecord {
  entity(id: X) {
    id
    name
  }
}
query SingleRecord {
  entity(id: Y) {
    id
    name
  }
}
```

Example of optimized querying:

```graphql
query ManyRecords {
  entities(where: { id_in: [X, Y] }) {
    id
    name
  }
}
```

### Combine multiple queries in a single request

アプリケーションでは、次のように複数の種類のデータをクエリする必要がある場合があります:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

この実装は完全に有効ですが、GraphQL API を使用した 2 つの往復が必要になります。

幸いなことに、次のように同じ GraphQL リクエストで複数のクエリを送信することも有効です:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`
```

このアプローチは、ネットワークに費やす時間を減少させる（APIへの往復を省略する）ため、**全体的なパフォーマンスを向上させます**。また、**より簡潔な実装**を提供します。

### GraphQLフラグメントの活用

GraphQL クエリを作成するのに役立つ機能は、GraphQL Fragment です。

次のクエリを見ると、いくつかのフィールドが複数のSelection-Sets（`{ ... }`）で繰り返されていることがわかります：

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

このような繰り返しフィールド (`id`、`active`、`status`) は、多くの問題を引き起こします。

- More extensive queries become harder to read.
- When using tools that generate TypeScript types based on queries (_more on that in the last section_), `newDelegate` and `oldDelegate` will result in two distinct inline interfaces.

クエリのリファクタリングされたバージョンは次のようになります:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

Using GraphQL `fragment` will improve readability (especially at scale) and result in better TypeScript types generation.

型生成ツールを使用すると、上記のクエリは適切な`DelegateItemFragment`型を生成します（_最後の「ツール」セクションを参照_）。

### GraphQLフラグメントの注意点

### フラグメントベースは型である必要があります

フラグメントは、適用できない型、つまり**フィールドを持たない型**に基づくことはできません。

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` は**スカラー** (ネイティブの「プレーン」タイプ) であり、フラグメントのベースとして使用できません。

#### フラグメントを拡散する方法

フラグメントは特定のタイプに定義されているため、クエリではそれに応じて使用する必要があります。

例：

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` と `oldDelegate` のタイプは `Transcoder` です。

ここでタイプ `Vote` のフラグメントを拡散することはできません。

#### フラグメントをデータのアトミックなビジネス単位として定義する

GraphQL `Fragment`s must be defined based on their usage.

ほとんどのユースケースでは、1つのタイプに対して1つのフラグメントを定義すること（繰り返しフィールドの使用または型生成の場合）で十分です。

Here is a rule of thumb for using fragments:

- When fields of the same type are repeated in a query, group them in a `Fragment`.
- When similar but different fields are repeated, create multiple fragments, for instance:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The Essential Tools

### GraphQL ウェブベースのエクスプローラ

Iterating over queries by running them in your application can be cumbersome. For this reason, don't hesitate to use [Graph Explorer](https://thegraph.com/explorer) to test your queries before adding them to your application. Graph Explorer will provide you a preconfigured GraphQL playground to test your queries.

If you are looking for a more flexible way to debug/test your queries, other similar web-based tools are available such as [Altair](https://altairgraphql.dev/) and [GraphiQL](https://graphiql-online.com/graphiql).

### GraphQL Linting

上記で述べたベストプラクティスと構文ルールに従うためには、以下のワークフローとIDEツールを使用することを強くお勧めします。

**GraphQL ESLint**

[GraphQL ESLint](https://the-guild.dev/graphql/eslint/docs/getting-started) will help you stay on top of GraphQL best practices with zero effort.

[Setup the "operations-recommended"](https://the-guild.dev/graphql/eslint/docs/configs) config will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: フィールドは適切なタイプで使用されているか？
- `@graphql-eslint/no-unused variables`: 与えられた変数は未使用のままであるべきか？
- ともっと

これにより、 プレイグラウンドでクエリをテストしたり、本番環境で実行したりせずに**エラーをキャッチできる** ようになります。

### IDE plugins

**VSCodeとGraphQL**

The [GraphQL VSCode Extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) is a great addition to your development workflow, allowing you to:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets
- Go to definition for fragments and input types

`graphql-eslint`を使用している場合、[ESLint VSCode拡張機能](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)はエラーや警告を正しくコード内に表示するために必須です。

**WebStorm/Intellij および GraphQL**

[JS GraphQLプラグイン](https://plugins.jetbrains.com/plugin/8097-graphql/)は、以下を提供することで、GraphQLを使用する際のエクスペリエンスを大幅に向上させます。

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets

For more information on this topic, check out the [WebStorm article](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) which showcases all the plugin's main features.
