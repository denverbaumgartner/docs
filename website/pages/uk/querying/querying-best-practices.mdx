---
title: Найкращі практики виконання запитів
---

The Graph provides a decentralized way to query data from blockchains via GraphQL APIs, making it easier to query data with the GraphQL language.

Learn the essential GraphQL language rules and GraphQL querying best practices.

---

## Запити в GraphQL API

### Анатомія запитів на GraphQL

На відміну від REST API, GraphQL API побудований на основі Schema, яка визначає, які запити можуть бути виконані.

Наприклад, запит на отримання токена за допомогою команди `token` буде виглядати наступним чином:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

який поверне наступну прогнозовану відповідь JSON (_при проходженні відповідного `$id` variable value_):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

Запити GraphQL використовують мову GraphQL, яка визначається [специфікацією](https://spec.graphql.org/).

Вищенаведений запит `GetToken` складається з декількох частин мови програмування (замінено нижче на вставку `[...]`):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

Хоча список синтаксичних "можна" і "не можна" довгий, ось основні правила, про які слід пам'ятати, коли йдеться про написання запитів в GraphQL:

- Кожне `queryName` може бути використане лише один раз за одну операцію.
- Кожне `field` може бути використане лише один раз за вибірку (ми не можемо запитувати `id` двічі `token`)
- Some `field`s or queries (like `tokens`) return complex types that require a selection of sub-field. Not providing a selection when expected (or providing one when not expected - for example, on `id`) will raise an error. To know a field type, please refer to [Graph Explorer](/network/explorer).
- Будь-яка змінна, що присвоюється параметру, повинна відповідати його типу.
- У заданому списку змінних кожна з них має бути унікальною.
- Всі задані змінні повинні бути використаними.

Недотримання вищевказаних правил призведе до отримання помилки від Graph API.

For a complete list of rules with code examples, please look at our [GraphQL Validations guide](/release-notes/graphql-validations-migration-guide/).

### Відправлення запиту до GraphQL API

GraphQL - це мова програмування і набір механізмів, які передаються через HTTP.

Це означає, що ви можете запитувати API GraphQL, використовуючи стандартні команди `fetch` (безпосередньо або через `@whatwg-node/fetch` or `isomorphic-fetch`).

However, as stated in ["Querying from an Application"](/querying/querying-from-an-application), it's recommend to use `graph-client` which supports unique features such as:

- Робота з кросс-чейн підграфами: Отримання інформації з декількох підграфів за один запит
- [Автоматичне відстежування блоків](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [Автоматична розбивка на сторінки](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- Повністю введений результат

Тут ви можете побачити, як робити запит в The Graph через `graph-client`:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

Інші альтернативні GraphQL клієнти описані в ["Querying from an Application"](/querying/querying-from-an-application).

---

## Найкращі практики

### Завжди пишіть статичні запити

Поширеною (негативною) практикою є динамічна побудова рядків запитів наступним чином:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

У наведеному вище фрагменті створено коректний запит до GraphQL, **він має багато недоліків**:

- це ** ускладнює розуміння** запиту в цілому
- розробник ** відповідає за безпечне очищення інтерполяції рядків**
- не передається значення змінних у складі параметрів запиту **, щоб запобігти можливому кешуванню на стороні сервера **
- це ** не дозволяє інструментам статично аналізувати запит ** (Linter, або інструменти для генерації типів)

З цієї причини рекомендується завжди писати запити як статичні рядки:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

Це приносить **багато користі**:

- **Легко читати та обслуговувати** запити
- The Graph Ql **сервер обробляє очищення змінних**
- **Змінні можуть бути кешовані** на рівні сервера
- **Запити можна статично аналізувати за допомогою інструментів** (більше про це в наступних розділах)

### How to include fields conditionally in static queries

You might want to include the `owner` field only on a particular condition.

For this, you can leverage the `@include(if:...)` directive as follows:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

> Примітка: Протилежною директивою є `@skip(if: ...)`.

### Ask for what you want

GraphQL став відомим завдяки своєму слогану "Ask what you want" ("Проси, що хочеш").

З цієї причини в GraphQL не існує способу отримати всі доступні поля без необхідності виведення кожного з них окремо.

- Запитуючи API GraphQL, завжди запитуйте тільки ті поля, які дійсно будуть використовуватися.
- Make sure queries only fetch as many entities as you actually need. By default, queries will fetch 100 entities in a collection, which is usually much more than what will actually be used, e.g., for display to the user. This applies not just to top-level collections in a query, but even more so to nested collections of entities.

Наприклад, у наступному запиті:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

Результат може містити 100 транзакцій для кожного зі 100 токенів.

Якщо програмі потрібно лише 10 транзакцій, у запиті слід явно задати `first: 10` у полі транзакцій.

### Use a single query to request multiple records

By default, subgraphs have a singular entity for one record. For multiple records, use the plural entities and filter: `where: {id_in:[X,Y,Z]}` or `where: {volume_gt:100000}`

Example of inefficient querying:

```graphql
query SingleRecord {
  entity(id: X) {
    id
    name
  }
}
query SingleRecord {
  entity(id: Y) {
    id
    name
  }
}
```

Example of optimized querying:

```graphql
query ManyRecords {
  entities(where: { id_in: [X, Y] }) {
    id
    name
  }
}
```

### Combine multiple queries in a single request

Ваша програма може потребувати запитів до декількох типів даних, як показано нижче:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

Хоча ця версія є цілком прийнятною, вона потребуватиме двох раундів звернень до API GraphQL.

На щастя, також допустимо надсилати декілька запитів в одному до GraphQL, як показано нижче:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

Такий підхід **покращить загальну продуктивність** за рахунок зменшення часу, витраченого на мережу (заощадить вам час на повернення до API) і забезпечить **компактнішу реалізацію**.

### Використання фрагментів GraphQL

Корисною функцією для написання запитів до GraphQL є GraphQL Fragment.

Дивлячись на наступний запит, ви помітите, що деякі поля повторюються в декількох Selection-Sets (`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

Такі поля, що повторюються (`id`, `active`, `status`) створюють багато проблем:

- More extensive queries become harder to read.
- When using tools that generate TypeScript types based on queries (_more on that in the last section_), `newDelegate` and `oldDelegate` will result in two distinct inline interfaces.

Рефакторизована версія запиту виглядатиме наступним чином:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

Using GraphQL `fragment` will improve readability (especially at scale) and result in better TypeScript types generation.

При використанні інструменту генерації типів, вищенаведений запит згенерує правильний `DelegateItemFragment` тип (_див. попередній розділ "Tools"_).

### Фрагмент GraphQL, що можна і що не можна робити

### База фрагменту повинна бути типом

Фрагмент не може ґрунтуватися на незастосовному типі, тобто на типі, що не має полів, тобто **на типі, що не має полів**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` - це **скалярний** (нативний "звичайний" тип), який не можна використовувати як основу фрагмента.

#### Як розповсюдити Фрагмент

Фрагменти визначені для певних типів і повинні використовуватися в запитах відповідно до цього.

Приклад:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` та `oldDelegate` відносяться до типу `Transcoder`.

Неможливо розповсюдити фрагмент типу `Vote` тут.

#### Визначте фрагмент як атомну бізнес-одиницю даних

GraphQL `Fragment`s must be defined based on their usage.

Для більшості випадків використання достатньо визначити один фрагмент для кожного типу (у випадку повторного використання полів або генерації типів).

Here is a rule of thumb for using fragments:

- When fields of the same type are repeated in a query, group them in a `Fragment`.
- When similar but different fields are repeated, create multiple fragments, for instance:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The Essential Tools

### GraphQL web-based explorers

Iterating over queries by running them in your application can be cumbersome. For this reason, don't hesitate to use [Graph Explorer](https://thegraph.com/explorer) to test your queries before adding them to your application. Graph Explorer will provide you a preconfigured GraphQL playground to test your queries.

If you are looking for a more flexible way to debug/test your queries, other similar web-based tools are available such as [Altair](https://altairgraphql.dev/) and [GraphiQL](https://graphiql-online.com/graphiql).

### GraphQL Linting

Для того, щоб відповідати вищезгаданим найкращим практикам і синтаксичним правилам, настійно рекомендується використовувати наступні робочі алгоритми та інструменти IDE.

**GraphQL ESLint**

[GraphQL ESLint](https://the-guild.dev/graphql/eslint/docs/getting-started) will help you stay on top of GraphQL best practices with zero effort.

[Setup the "operations-recommended"](https://the-guild.dev/graphql/eslint/docs/configs) config will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: чи використовується поле належного типу?
- `@graphql-eslint/no-unused variables`: чи повинна дана змінна залишатися невикористаною?
- та більше!

Це дозволить вам **помічати помилки, навіть не тестуючи запити** в тестовому просторі або запускати їх у якості продукту!

### Плагіни IDE

**VSCode і GraphQL**

[GraphQL VSCode розширення](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) є чудовим доповненням до вашого процесу розробки, щоб отримати:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets
- Go to definition for fragments and input types

Якщо ви використовуєте `graphql-eslint`, [ESLint VSCode розширення](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint), що вкрай необхідне для правильної візуалізації помилок та попереджень, закладених у вашому коді.

**WebStorm/Intellij і GraphQL**

[JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-graphql/) значно покращить ваш досвід роботи з GraphQL, надавши:

- Syntax highlighting
- Autocomplete suggestions
- Validation against schema
- Snippets

For more information on this topic, check out the [WebStorm article](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) which showcases all the plugin's main features.
